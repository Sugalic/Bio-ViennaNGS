<?xml version="1.0" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title></title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:root@localhost" />
</head>

<body style="background-color: white">



<ul id="index">
  <li><a href="#Example-One">Example One</a>
    <ul>
      <li><a href="#SYNOPSIS">SYNOPSIS</a></li>
      <li><a href="#Pipeline">Pipeline</a></li>
      <li><a href="#Generate-a-Bio::ViennaNGS::FeatureChain-object">Generate a Bio::ViennaNGS::FeatureChain object</a></li>
      <li><a href="#Extend-the-existing-chain-for-motif-analysis">Extend the existing chain for motif analysis</a></li>
      <li><a href="#Print-extended-Bio::ViennaNGS::FeatureChain-objects-to-files">Print extended Bio::ViennaNGS::FeatureChain objects to files</a>
        <ul>
          <li><a href="#Summary-of-so-far-used-methods">Summary of so far used methods</a></li>
        </ul>
      </li>
      <li><a href="#Sequence-analysis">Sequence analysis</a></li>
    </ul>
  </li>
  <li><a href="#Pipeline6">Pipeline6</a></li>
  <li><a href="#AUTHOR">AUTHOR</a></li>
</ul>

<h1 id="Example-One">Example One</h1>

<pre><code>    Pipeline.pl - An example pipeline for the ViennaNGS toolbox</code></pre>

<h2 id="SYNOPSIS">SYNOPSIS</h2>

<pre><code>   ./Pipeline.pl path/to/R/libraries
    Where path/to/R/libraries should point to the directory containing ggplot2</code></pre>

<h2 id="Pipeline">Pipeline</h2>

<pre><code>    This script is a showcase for the usage of ViennaNGS in a real NGS example.
    We start from a file containing ENSEMBL annotation information for human protein-coding genes.
    We are insterested in finding sequence motifs in close proximity to the gene start (50nt upstream, 10nt into the gene).

    The first step is to initialize some variables and generate a chromosome_sizes hash.
    
    C&lt;my $genome = &#39;hg19.chrom.size&#39;;&gt;

    If the chromosome sizes file is not yet available, 
    one can use the UCSC Genome Browser&#39;s MySQL database 
    to extract chromosome sizes as follows, e.g. hg19:
    C&lt;mysql --user=genome --host=genome-mysql.cse.ucsc.edu -A -e \
    &quot;select chrom, size from hg19.chromInfo&quot; &gt; hg19.chrom.sizes&gt;

    C&lt;my $bed    = &#39;hg19_highlyexpressed.bed&#39;;&gt;
    C&lt;my $name     = (split(/\./,$bed))[0];&gt;
    C&lt;my $upstream = 50;&gt;
    C&lt;my $into     = 10;&gt;
    C&lt;my $outfile  = &quot;$name.ext$upstream\_fromStart_$into\_downstream.bed&quot;;&gt;
    C&lt;my $outfile2 = &quot;$name.ext$upstream\_upstream.bed&quot;;&gt;

    C&lt;open (my $Genome, &quot;&lt;:gzip(autopop)&quot;,$g) or die &quot;$!&quot;;&gt;
    C&lt;open (my $Out, &quot;&gt;&quot;,$o) or die &quot;$!&quot;;&gt;

    C&lt;my %sizes;&gt;

    C&lt;while (&lt;$Genome&gt;){
        chomp $_;
        my ($chr,$size)=split (/\t/,$_);
       $sizes{$chr}=$size;
   }&gt;



    </code></pre>

<h2 id="Generate-a-Bio::ViennaNGS::FeatureChain-object">Generate a Bio::ViennaNGS::FeatureChain object</h2>

<pre><code>    The bed file of interest is parsed, a feature array is generated and passed on to Bio::ViennaNGS::FeatureChain, which creates a new Moose Object of type FeatureChain, containing the original bed entries
    C&lt;my @featurelist = @{parse_bed6($bed)};
    ### Now we create a Bio::ViennaNGS::FeatureChain from the featurelist above
    my $chain = Bio::ViennaNGS::FeatureChain-&gt;new(&#39;type&#39;=&gt;&#39;original&#39;,&#39;chain&#39;=&gt;\@featurelist);&gt;
    </code></pre>

<h2 id="Extend-the-existing-chain-for-motif-analysis">Extend the existing chain for motif analysis</h2>

<pre><code>    The newly created FeatureChain object will now be extended 50nt upstream of the gene start and 10nt into the gene, to retrieve a bed file which contains the putative sequence motifs.
    
    C&lt;my $extended_chain = extend_chain(\%sizes,$chain,0,$into,$upstream,0);&gt;
    
    For later purposes we also extend the whole U6 gene span 50nt upstream.
    C&lt;my $extended_chain2 = extend_chain(\%sizes,$chain,$upstream,0,0,0);&gt;</code></pre>

<h2 id="Print-extended-Bio::ViennaNGS::FeatureChain-objects-to-files">Print extended Bio::ViennaNGS::FeatureChain objects to files</h2>

<pre><code>    Extended chains are now print out to make them available for external tools like bedtools.
    C&lt;my $out = $extended_chain-&gt;print_chain();
    print $Out $out;
    $out = $extended_chain2-&gt;print_chain();
    print $Out2 $out;&gt;</code></pre>

<h3 id="Summary-of-so-far-used-methods">Summary of so far used methods</h3>

<dl>

<dt id="parse_bed6as_string">parse_bed6&lt;as_string&gt;</dt>
<dd>

<pre><code>    Reads a bed6 file and returns a feature array.</code></pre>

</dd>
<dt id="Bio::ViennaNGS::FeatureChain-new-as_method">Bio::ViennaNGS::FeatureChain-&gt;new()&lt;as_method&gt;</dt>
<dd>

<pre><code>    Generates a new Bio::ViennaNGS::FeatureChain object from a feature array</code></pre>

</dd>
<dt id="Bio::ViennaNGS-extend_chain-as_method">Bio::ViennaNGS(extend_chain)&lt;as_method&gt;</dt>
<dd>

<pre><code>    Extends a Bio::ViennaNGS::FeatureChain object by given constraints</code></pre>

</dd>
</dl>

<h2 id="Sequence-analysis">Sequence analysis</h2>

<pre><code>    We now generate FASTA files from the extended bed files using bedtools getfasta method.
    C&lt;my $bedtools = `bedtools getfasta -s -fi hg19_chromchecked.fa -bed $outfile -fo $name.ext$upstream\_fromStart_$into\_downstream.fa`;&gt;
    C&lt;print STDERR &quot;$bedtools\n&quot; if $?;&gt;
    C&lt;$bedtools = `bedtools getfasta -s -fi hg19_chromchecked.fa -bed $outfile2 -fo $name.ext$upstream\_upstream.fa`;&gt;
    C&lt;print STDERR &quot;$bedtools\n&quot; if $?;&gt;

    To analyze putative sequence motifs in the newly generated Fasta files, we use two approaches.
    First we analyze the k-mer content with the Bio::ViennaNGS(kmer_enrichment) method for k-mers of length 6 to 8 nt.

    C&lt;open(IN,&quot;&lt;&quot;,&quot;$name.ext$upstream\_fromStart_$into\_downstream.fa&quot;) || die (&quot;Could not open $name.ext$upstream\_fromStart_$into\_downstream.fa!\n@!\n&quot;);&gt;

    C&lt;my @fastaseqs;&gt;
    C&lt;while(&lt;IN&gt;){
          chomp (my $raw = $_);
          next if ($_ =~ /^&gt;/);
          push @fastaseqs, $raw;
    }&gt;
    C&lt;close(IN);&gt;

    C&lt;for (6..8){
         my %kmer = %{kmer_enrichment(\@fastaseqs, $_)};
         my $total = sum values %kmer;
         ### Print Output
         open(KMER,&quot;&gt;&quot;,&quot;$_\_mers&quot;) or die &quot;Could not open file $_\_mers$!\n&quot;;
         print KMER &quot;$_\-mer\tCount\tRatio\n&quot;;
         print KMER &quot;TOTAL\t$total\t1\n&quot;;
         foreach my $key  (sort {$kmer{$b} &lt;=&gt; $kmer{$a} } keys %kmer) {
             my $ratio = nearest(.0001,$kmer{$key}/$total);
             print KMER &quot;$key\t$kmer{$key}\t$ratio\n&quot;;
         }
         close(KMER);
    }&gt;</code></pre>

<h1 id="Pipeline6">Pipeline6</h1>

<pre><code>    In a second approach we run MEME to retrieve the 20 most over-represented motifs of length 7-10.
    meme.bin U6.ext200fromStart_20downstream.fa -oc Meme_U6 -minw 7 -maxw 10 -dna -nmotifs 20 -maxsize 10000000

    Once the meme run is done, we want to have a nice figure which shows the e-value and site coverage of the top 10 motifs

    C&lt;&#39;./scripts/MEME_xml_motif_extractor.pl -f Example_Pipeline_meme.xml -r $RLIBPATH -t Example_Pipeline&#39;&gt;</code></pre>

<h1 id="AUTHOR">AUTHOR</h1>

<p>Joerg Fallmann &lt;joerg.fallmann@univie.ac.at&gt;</p>


</body>

</html>


