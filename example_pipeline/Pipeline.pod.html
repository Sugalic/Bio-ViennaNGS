<?xml version="1.0" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title></title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:root@localhost" />
</head>

<body style="background-color: white">



<ul id="index">
  <li><a href="#NAME">NAME</a></li>
  <li><a href="#SYNOPSIS">SYNOPSIS</a></li>
  <li><a href="#Pipeline">Pipeline</a></li>
  <li><a href="#Pipeline2">Pipeline2</a></li>
  <li><a href="#Pipeline3">Pipeline3</a></li>
  <li><a href="#Pipeline4">Pipeline4</a>
    <ul>
      <li><a href="#Methods">Methods</a></li>
    </ul>
  </li>
  <li><a href="#Pipeline5">Pipeline5</a></li>
  <li><a href="#Pipeline6">Pipeline6</a></li>
  <li><a href="#AUTHOR">AUTHOR</a></li>
</ul>

<h1 id="NAME">NAME</h1>

<pre><code>    Pipeline.pl - An example pipeline for the ViennaNGS toolbox</code></pre>

<h1 id="SYNOPSIS">SYNOPSIS</h1>

<pre><code>   ./Pipeline.pl path/to/R/libraries</code></pre>

<h1 id="Pipeline">Pipeline</h1>

<pre><code>    This script is a showcase for the usage of ViennaNGS in a real NGS example.
    We start from a file containing ENSEMBL annotation information for U6-RNA coding genes.
    We are insterested in finding sequence motifs in close proximity to the gene start (200nt upstream), which mark annotated genes as transcribed by Polymerase III.

    First step is to initialize some variables we need, and generate a chromosome_sizes hash.
    
    C&lt;my $genome = &#39;mm9.chrom.sizes&#39;;
    my $bed = &#39;U6.bed&#39;;
    my $upstream = 200;
    my $downstream = 20;
    my $outfile = &#39;U6.ext200up_20in.bed&#39;;

    open (my $Genome, &quot;&lt;:gzip(autopop)&quot;,$g) or die &quot;$!&quot;;
    open (my $Out, &quot;&gt;&quot;,$o) or die &quot;$!&quot;;

    my %sizes;

    while (&lt;$Genome&gt;){
        chomp $_;
        my ($chr,$size)=split (/\t/,$_);
       $sizes{$chr}=$size;
   }&gt;
    </code></pre>

<h1 id="Pipeline2">Pipeline2</h1>

<pre><code>    Then the bed file of interest is parsed, features are generated and passed on to Bio::ViennaNGS::FeatureChain, which creates a new Moose Object of type FeatureChain, containing the original bed entries
    C&lt;my @featurelist = @{parse_bed6($bed)};
    ### Now we create a Bio::ViennaNGS::FeatureChain from the featurelist above
    my $chain = Bio::ViennaNGS::FeatureChain-&gt;new(&#39;type&#39;=&gt;&#39;original&#39;,&#39;chain&#39;=&gt;\@featurelist);&gt;
    </code></pre>

<h1 id="Pipeline3">Pipeline3</h1>

<pre><code>    The newly created FeatureChain object will now be extended 200nt upstream of the gene start and 20nt into the gene, to retrieve a bed file which contains the putative sequence motifs.
    
    C&lt;my $extended_chain = extend_chain(\%sizes,$chain,0,$into,$upstream,0);&gt;
    
    For later purposes we also extend the whole U6 gene span 200nt upstream.
    C&lt;my $extended_chain2 = extend_chain(\%sizes,$chain,200,0,0,0);&gt;</code></pre>

<h1 id="Pipeline4">Pipeline4</h1>

<pre><code>    Extended chains are now print out to make them available for external tools like bedtools.
    C&lt;my $out = $extended_chain-&gt;print_chain();
    print $Out $out;
    $out = $extended_chain2-&gt;print_chain();
    print $Out2 $out;&gt;</code></pre>

<h2 id="Methods">Methods</h2>

<dl>

<dt id="parse_bed6as_string">parse_bed6&lt;as_string&gt;</dt>
<dd>

<pre><code>    Reads a bed6 file and returns a feature array.</code></pre>

</dd>
<dt id="Bio::ViennaNGS::FeatureChain-new-as_method">Bio::ViennaNGS::FeatureChain-&gt;new()&lt;as_method&gt;</dt>
<dd>

<pre><code>    Generates a new Bio::ViennaNGS::FeatureChain object from a feature array</code></pre>

</dd>
<dt id="Bio::ViennaNGS-extend_chain-as_method">Bio::ViennaNGS(extend_chain)&lt;as_method&gt;</dt>
<dd>

<pre><code>    Extends a Bio::ViennaNGS::FeatureChain object by given constraints</code></pre>

</dd>
</dl>

<h1 id="Pipeline5">Pipeline5</h1>

<pre><code>    We now generate FASTA files from the extended bed files using bedtools getfasta method.
    I&lt;`bedtools getfasta -fi hg19_chromchecked.fa -bed U6.ext200fromStart_20downstream.bed -fo U6.ext200fromStart_20downstream.fa -s`
    `bedtools getfasta -fi hg19_chromchecked.fa -bed U6.ext200upstream.bed -fo U6.ext200upstream.fa -s`&gt;

    To analyze the sequence motif content of the newly generated Fasta files, we use two approaches.
    First we analyze the k-mer content with the Bio::ViennaNGS(kmer_enrichment) method for k-mers of length 7 to 10 nt.

    C&lt;open(IN,&quot;&lt;&quot;,&quot;U6.ext200fromStart_20downstream.fa&quot;) || die (&quot;Could not open $file!\n@!\n&quot;);

    my @fastaseqs;
    while(&lt;IN&gt;){
        chomp (my $raw = $_);
        push @fastaseqs, $raw;
    }
    close(IN);

    for (7..10){
        %kmer = %{kmer_enrichment(\@seqs, $_)};
        my $total = sum values %kmer;
        ### Print Output
        open(KMER,&quot;&gt;&quot;,&quot;$_\_mers&quot;) or die &quot;Could not open file $!\n&quot;;
        print KMER &quot;$_\-mer\tCount\tRatio\n&quot;;
        print KMER &quot;TOTAL\t$total\t1\n&quot;;
        foreach my $key  (sort {$kmer{$b} &lt;=&gt; $kmer{$a} } keys %kmer) {
            my $ratio = $kmer{$key}/$total;
            print KMER &quot;$key\t$kmer{$key}\t$ratio\n&quot;;
        }
        close(KMER);
    }&gt;</code></pre>

<h1 id="Pipeline6">Pipeline6</h1>

<pre><code>    In a second approach we run MEME to retrieve the 20 most over-represented motifs of length 7-10.
    meme.bin U6.ext200fromStart_20downstream.fa -oc Meme_U6 -minw 7 -maxw 10 -dna -nmotifs 20 -maxsize 10000000

    Once the meme run is done, we want to have a nice figure which shows the e-value and site coverage of the top 10 motifs

    C&lt;&#39;./scripts/MEME_xml_motif_extractor.pl -f  meme.xml -r $RLIBPATH -t U6&#39;&gt;</code></pre>

<h1 id="AUTHOR">AUTHOR</h1>

<p>Joerg Fallmann &lt;joerg.fallmann@univie.ac.at&gt;</p>


</body>

</html>


